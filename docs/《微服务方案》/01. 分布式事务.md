
## 资料
- https://mp.weixin.qq.com/s/abjDjGGz5RUoCNCdnoxOjQ
- https://github.com/javagrowing/JGrowing
- https://cloud.tencent.com/developer/article/1903539
- http://icyfenix.cn/architect-perspective/general-architecture/transaction/distributed.html


## 背景知识
ACID 数据库事务特性，
- A 原子性(Atomicity)
- C 一致性(Consistency)
- I 隔离性(Isolation)
- D 持久性(Durability)

InnoDB 是通过日志（redo log)和锁保障,事务的隔离性是通过数据锁的机制实现，持久性是通过redo log（重做日志）  

典型的场景是支付场景中，余额、积分、优惠卷的场景，由于是多库多节点，利用上面数据的ACID没有办法满足要求，所以行业提出新的理论

## 理论基础
### CAP定理
- C  (一致性):对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据
- A (可用性)故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应),要求请求不能阻塞
- P (分区容错性) 打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。

对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。

对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展

### BASE
BASE 其实是AP 的扩展
1. 基本可用，出现故障的时候，核心功能可用
2. 软状态，允许中间状态，
3. 最终一致性


## 解决方案

### 2PC 1.0
- TC (Transaction Coordinator) - 事务协调者
维护全局和分支事务的状态，驱动全局事务提交或回滚。

- TM (Transaction Manager) - 事务管理器
定义全局事务的范围：开始全局事务、提交或回滚全局事务。

- RM (Resource Manager) - 资源管理器
  

XA 协议(数据库分布式事务中的 XA Transactions)
第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.
第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。

缺点：
单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机,事务管理器出现宕机，或者阻塞，整个系统无法使用
同步阻塞:资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。
数据不一致：网络问题该通知仅被一部分参与者没有收到回应


### TCC 2.0
TCC 的提出，为了解决XA协议确定
1. 协调者单点问题，协调者也可以变成集群
2. 同步阻塞，引入超时和超时补偿
3. 数据最终一致性，引入补偿机制，由业务活动管理控制

解释   
- Try 阶段 ，尝试执行，完成所有业务检查，预留业务资源
- Comfirm 阶段，确认执行真正业务，不作任务业务检查，Comfirm 操作满足幂等性
- Cancel 阶段，取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。
  

### 本地消息表  ebay方案 base理论 3.0
分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。
1. 你扣钱和写入减去水的库存到本地消息表放入同一个事务(依靠数据库本地事务保证一致性。
2. 定时轮询本地事务表状态
3. 下游商品服务定时扫描事务表，进行状态更新
4. 针对异常情况，重试和幂等


### MQ事务
RocketMQ 实现的分布式，实际上也是对本地消息表的一个封装
1. 第一阶段prepared 会拿到消息地址
2. 执行本地事务。
3. 第三阶段通过第一阶段拿到的地址去访问消息，修改状态，消息接受者就可以使用这个消息； 如果消息没有得到确认，会想消息发送者发送消息，来判断是否提交，消息端要保持幂等


### Sago 事务   
其核心思想是将长事务拆分为多个本地短事务，T1, T2, T3, ..., Tn





